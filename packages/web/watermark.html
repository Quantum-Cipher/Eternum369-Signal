<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WatermarkSafe V2 - Cryptographic Demo with Gemini AI</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>
  <style>
    body { font-family: 'Inter', sans-serif; }
    .card { background-color: white; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); padding: 1.5rem; margin-bottom: 1.5rem; border: 1px solid #e5e7eb; }
    .btn { display: inline-flex; align-items: center; justify-content: center; padding: 0.75rem 1.5rem; font-weight: 500; border-radius: 0.5rem; cursor: pointer; transition: background-color 0.2s; }
    .btn-primary { background-color: #4f46e5; color: white; }
    .btn-primary:hover { background-color: #4338ca; }
    .btn-secondary { background-color: #e5e7eb; color: #374151; }
    .btn-secondary:hover { background-color: #d1d5db; }
    .btn-ai { background-color: #818cf8; color: white; }
    .btn-ai:hover { background-color: #6366f1; }
    textarea { font-family: monospace; font-size: 0.875rem; line-height: 1.25rem; border-radius: 0.5rem; border: 1px solid #d1d5db; padding: 0.5rem; width: 100%; min-height: 120px; resize: vertical; }
    .status-box { padding: 1rem; border-radius: 0.5rem; margin-top: 1rem; font-weight: 500; }
    .status-success { background-color: #dcfce7; color: #166534; border: 1px solid #86efac; }
    .status-error { background-color: #fee2e2; color: #991b1b; border: 1px solid #fca5a5; }
    .loader { border: 4px solid #f3f3f3; border-top: 4px solid #4f46e5; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; margin-right: 0.75rem; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    nav a { margin-right: 20px; color: #4f46e5; font-weight: 600; text-decoration: none;}
  </style>
</head>

<body class="bg-gray-50 text-gray-800">
  <div class="container mx-auto p-4 md:p-8 max-w-4xl">
    <nav class="mb-8 text-center">
        <a href="index.html">Vision</a>
        <a href="architecture.html">Architecture</a>
        <a href="data_chain.html">Data Security</a>
        <a href="watermark.html" style="text-decoration: underline;">Watermark App</a>
    </nav>
    <header class="text-center mb-8">
      <h1 class="text-4xl font-bold text-gray-900">WatermarkSafe V2</h1>
      <p class="text-lg text-gray-600 mt-2">Cryptographic Watermarking with Gemini AI</p>
    </header>

    <div class="card"><h2 class="text-2xl font-semibold mb-4 border-b pb-2">Step 1: Generate Your Identity</h2><p class="mb-4 text-gray-600">Create a new ECDSA public/private key pair. Your private key signs content; your public key lets others verify it.</p><button id="generateKeysBtn" class="btn btn-primary">Generate Key Pair</button><div id="keyGenLoader" class="hidden items-center mt-4"><div class="loader"></div><span>Generating secure keys...</span></div><div id="keysContainer" class="hidden mt-4 space-y-4"><div><label class="font-semibold text-gray-700">Private Key (Keep this secret!)</label><textarea id="privateKeyText" readonly></textarea></div><div><label class="font-semibold text-gray-700">Public Key (Share this freely)</label><textarea id="publicKeyText" readonly></textarea></div></div></div>
    <div class="card"><h2 class="text-2xl font-semibold mb-4 border-b pb-2">Step 2: Sign & Watermark an Image</h2><p class="mb-4 text-gray-600">Upload an image, generate AI-powered metadata, and use your private key to create a signed, watermarked version.</p><div class="space-y-4"><div><label for="imageUpload" class="font-semibold text-gray-700">1. Upload Image (PNG recommended)</label><input type="file" id="imageUpload" accept="image/png, image/jpeg" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/></div><div><label for="metadataInput" class="font-semibold text-gray-700">2. Add or Generate Metadata</label><div class="flex items-center space-x-2"><input type="text" id="metadataInput" placeholder="Enter metadata or generate with AI" class="w-full p-2 border border-gray-300 rounded-md"/><button id="generateMetadataBtn" class="btn btn-ai">✨ Generate</button></div><div id="metadataLoader" class="hidden items-center mt-2"><div class="loader !w-5 !h-5"></div><span>Gemini is analyzing the image…</span></div></div><div><label for="privateKeySign" class="font-semibold text-gray-700">3. Paste Your Private Key to Sign</label><textarea id="privateKeySign" placeholder="Paste your generated private key here"></textarea></div><button id="signBtn" class="btn btn-primary">Sign & Watermark Image</button><div id="signLoader" class="hidden items-center mt-4"><div class="loader"></div><span>Canonicalizing, hashing, signing, and embedding… This may take a moment.</span></div><div id="signResult" class="hidden mt-4"><div id="signStatus" class="status-box"></div><div class="mt-4"><h3 class="font-semibold">Watermarked Image:</h3><canvas id="watermarkedCanvas" class="mt-2 border border-gray-300 rounded-md max-w-full"></canvas><a id="downloadLink" class="btn btn-secondary mt-2">Download Watermarked PNG</a></div></div></div></div>
    <div class="card"><h2 class="text-2xl font-semibold mb-4 border-b pb-2">Step 3: Verify & Analyze an Image</h2><p class="mb-4 text-gray-600">Upload a watermarked image and provide the creator's public key to verify its authenticity and generate an AI-powered analysis.</p><div class="space-y-4"><div><label for="verifyUpload" class="font-semibold text-gray-700">1. Upload Watermarked Image</label><input type="file" id="verifyUpload" accept="image/png, image/jpeg" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/></div><div><label for="publicKeyVerify" class="font-semibold text-gray-700">2. Paste Creator's Public Key</label><textarea id="publicKeyVerify" placeholder="Paste the public key of the person who signed the image"></textarea></div><button id="verifyBtn" class="btn btn-primary">Verify Image</button><div id="verifyLoader" class="hidden items-center mt-4"><div class="loader"></div><span>Extracting signature and verifying…</span></div><div id="verifyResult" class="hidden mt-4"><div id="verifyStatus" class="status-box"></div><div id="aiReportSection" class="hidden mt-4"><button id="generateReportBtn" class="btn btn-ai">✨ Generate AI Content Report</button><div id="reportLoader" class="hidden items-center mt-2"><div class="loader !w-5 !h-5"></div><span>Gemini is generating the report…</span></div></div><div id="reportContainer" class="mt-4 p-4 border border-gray-200 rounded-md bg-gray-50 hidden"></div></div></div></div>
    
  <script>
    // --- UTILITIES & HELPER FUNCTIONS (replicated for execution) ---
    function str2ab(str) { const buf = new ArrayBuffer(str.length); const bufView = new Uint8Array(buf); for (let i = 0; i < str.length; i++) bufView[i] = str.charCodeAt(i); return buf; }
    function b642ab(b64) { return str2ab(atob(b64)); }
    function ab2b64(ab) { return btoa(String.fromCharCode(...new Uint8Array(ab))); }
    function fileToBase64(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = () => resolve(reader.result.split(',')[1]); reader.onerror = reject; }); }
    async function callGemini(prompt, base64, mime) { return new Promise(resolve => setTimeout(() => resolve("AI Simulation: " + prompt + " [Analysis complete]"), 1500)); }
    function getImageDataFromUpload(input) { return new Promise((resolve, reject) => { if(!input.files[0]) reject("No file selected."); const img = new Image(); img.onload = () => { const c = document.createElement('canvas'); c.width = img.width; c.height = img.height; const ctx = c.getContext('2d'); ctx.drawImage(img, 0, 0); resolve(ctx.getImageData(0,0, c.width, c.height)); }; img.onerror = () => reject("Image loading failed."); img.src = URL.createObjectURL(input.files[0]); }); }
    async function createPayload(imageData, meta) { const data = new Uint8Array(imageData.data); const metaBuf = str2ab(meta); const combined = new Uint8Array(data.length + metaBuf.length); combined.set(data); combined.set(new Uint8Array(metaBuf), data.length); return combined; }
    async function importPrivateKey(pem) { const binaryDer = b642ab(pem); return window.crypto.subtle.importKey('pkcs8', binaryDer, { name: "ECDSA", namedCurve: "P-256" }, true, ["sign"]); }
    async function importPublicKey(pem) { const binaryDer = b642ab(pem); return window.crypto.subtle.importKey('spki', binaryDer, { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]); }
    function embedDataInImage(imageData, stegoJson) { const str = stegoJson + "|END|"; const binary = str.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join(''); const newImageData = new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height); for(let i=0; i<binary.length; i++) { if (i*4 >= newImageData.data.length) break; const val = newImageData.data[i*4]; newImageData.data[i*4] = (val & 0xFE) | parseInt(binary[i]); } return newImageData; }
    function extractDataFromImage(imageData) { let binary = ""; for(let i=0; i<imageData.data.length/4; i++) { binary += (imageData.data[i*4] & 1).toString(); } let str = ""; for(let i=0; i<binary.length; i+=8) { const byte = binary.slice(i, i+8); const char = String.fromCharCode(parseInt(byte, 2)); str += char; if (str.endsWith("|END|")) return JSON.parse(str.replace("|END|", "")); if (str.length > 5000) break; } return null; }

    // --- MAIN EVENT LISTENERS (Initial Logic) ---
    const generateKeysBtn = document.getElementById('generateKeysBtn');
    const privateKeyText = document.getElementById('privateKeyText');
    const publicKeyText = document.getElementById('publicKeyText');
    const keyGenLoader = document.getElementById('keyGenLoader');
    const keysContainer = document.getElementById('keysContainer');
    const signBtn = document.getElementById('signBtn');
    const verifyBtn = document.getElementById('verifyBtn');
    const generateMetadataBtn = document.getElementById('generateMetadataBtn');
    const generateReportBtn = document.getElementById('generateReportBtn');
    const metadataLoader = document.getElementById('metadataLoader');
    const reportLoader = document.getElementById('reportLoader');
    const metadataInput = document.getElementById('metadataInput');
    const imageUpload = document.getElementById('imageUpload');
    const verifyUpload = document.getElementById('verifyUpload');
    const reportContainer = document.getElementById('reportContainer');
    
    // Key Generation Logic (replicated from your original script)
    generateKeysBtn.addEventListener('click', async () => {
      keyGenLoader.style.display = 'flex'; keysContainer.style.display = 'none';
      try {
        const kp = await window.crypto.subtle.generateKey({ name: 'ECDSA', namedCurve: 'P-256' }, true, ['sign', 'verify']);
        const priv = await window.crypto.subtle.exportKey('pkcs8', kp.privateKey);
        const pub = await window.crypto.subtle.exportKey('spki', kp.publicKey);
        privateKeyText.value = ab2b64(priv); publicKeyText.value = ab2b64(pub);
        keysContainer.style.display = 'block';
      } catch (e) { alert("Key Generation Error: " + e.message); } finally { keyGenLoader.style.display = 'none'; }
    });

    // Sign/Watermark Logic (replicated from your original script)
    signBtn.addEventListener('click', async () => {
        const meta = document.getElementById('metadataInput').value;
        const pk = document.getElementById('privateKeySign').value;
        if(!imageUpload.files[0] || !meta || !pk) return alert("Missing inputs");
        
        document.getElementById('signLoader').style.display = 'flex';
        try {
            const imgData = await getImageDataFromUpload(imageUpload);
            const privKey = await importPrivateKey(pk);
            const signature = await window.crypto.subtle.sign({name: "ECDSA", hash: {name: "SHA-256"}}, privKey, str2ab(meta));
            
            const stegoPayload = JSON.stringify({ sig: ab2b64(signature), meta: meta });
            const watermarked = embedDataInImage(imgData, stegoPayload);
            
            const cvs = document.getElementById('watermarkedCanvas');
            cvs.width = watermarked.width; cvs.height = watermarked.height;
            cvs.getContext('2d').putImageData(watermarked, 0, 0);
            
            document.getElementById('signResult').style.display = 'block';
            document.getElementById('downloadLink').href = cvs.toDataURL();
            document.getElementById('signStatus').innerHTML = "Success! Download below.";
            document.getElementById('signStatus').className = "status-box status-success";
        } catch(e) { console.error(e); alert("Signing Error: " + e.message); 
            document.getElementById('signStatus').innerHTML = "Error: " + e.message;
            document.getElementById('signStatus').className = "status-box status-error";
            document.getElementById('signResult').style.display = 'block';
        }
        finally { document.getElementById('signLoader').style.display = 'none'; }
    });
    
    // Verify Logic (replicated from your original script)
    verifyBtn.addEventListener('click', async () => {
        const pubK = document.getElementById('publicKeyVerify').value;
        if(!verifyUpload.files[0] || !pubK) return alert("Missing inputs");

        document.getElementById('verifyLoader').style.display = 'flex';
        try {
            const imgData = await getImageDataFromUpload(verifyUpload);
            const extracted = extractDataFromImage(imgData);
            if(!extracted) throw new Error("No watermark data found in image.");
            
            const pubKey = await importPublicKey(pubK);
            const valid = await window.crypto.subtle.verify({name: "ECDSA", hash: {name: "SHA-256"}}, pubKey, b642ab(extracted.sig), str2ab(extracted.meta));
            
            const resDiv = document.getElementById('verifyStatus');
            if(valid) {
                resDiv.innerHTML = "<strong>VERIFIED:</strong> Signature valid. Metadata: " + extracted.meta;
                resDiv.className = "status-box status-success";
                document.getElementById('aiReportSection').style.display = 'block'; // Show AI button on success
            } else {
                resDiv.innerHTML = "<strong>VERIFICATION FAILED:</strong> Content altered or key incorrect.";
                resDiv.className = "status-box status-error";
            }
            document.getElementById('verifyResult').style.display = 'block';
        } catch(e) { 
            document.getElementById('verifyStatus').innerHTML = "Error: " + e.message;
            document.getElementById('verifyStatus').className = "status-box status-error";
            document.getElementById('verifyResult').style.display = 'block';
        }
        finally { document.getElementById('verifyLoader').style.display = 'none'; }
    });
    
    // AI Metadata Generation Logic (replicated from your original script)
    generateMetadataBtn.addEventListener('click', async () => {
      if (!imageUpload.files[0]) return alert('Upload an image first.');
      metadataLoader.style.display = 'flex'; metadataInput.value = '';
      try {
        const file = imageUpload.files[0];
        const b64 = await fileToBase64(file);
        metadataInput.value = await callGemini('Briefly describe this image in one sentence for metadata.', b64, file.type);
      } catch (err) { alert("AI Error: " + err.message); } finally { metadataLoader.style.display = 'none'; }
    });
    
    // AI Report Generation Logic (replicated from your original script)
    generateReportBtn.addEventListener('click', async () => {
      if (!verifyUpload.files[0]) return alert('Verify an image first.');
      reportLoader.style.display = 'flex'; reportContainer.style.display = 'none';
      try {
        const file = verifyUpload.files[0];
        const b64 = await fileToBase64(file);
        reportContainer.innerText = await callGemini('Provide a detailed analysis of this image, describing its contents, style, and potential context.', b64, file.type);
        reportContainer.style.display = 'block';
      } catch (err) { reportContainer.innerText = `Error: ${err.message}`; reportContainer.style.display = 'block'; } 
      finally { reportLoader.style.display = 'none'; }
    });

  </script>
</body>
</html>
